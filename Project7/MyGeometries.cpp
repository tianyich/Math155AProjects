//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;
phMaterial metalMaterial;
phMaterial donutMaterial;
// **************************
// Information for loading textures
// **************************
const int NumTextures = 6;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "floor.bmp",
    "steel.bmp",
    "donut.bmp",
    "testcube.bmp",
    "dough.bmp",
    "wall.bmp",
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(meshRes, meshRes, meshRes);
GlGeomTorus texTorus(meshRes, meshRes, 0.6);



// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 4;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;    
const int iCube  = 3;
// RESERVED FOR USE BY 155A PROJECT

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    metalMaterial.SpecularColor.Set(0.7,0.7,0.7);
    metalMaterial.AmbientColor.Set(0.2, 0.2, 0.2);
    metalMaterial.DiffuseColor.Set(0.8, 0.8, 0.8);
    metalMaterial.SpecularExponent = 20.0;

    donutMaterial.SpecularColor.Set(0.1, 0.1, 0.1);
    donutMaterial.AmbientColor.Set(0.2, 0.2, 0.2);
    donutMaterial.DiffuseColor.Set(0.8, 0.8, 0.8);
    donutMaterial.SpecularExponent = 80.0;
    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -8.0f, 0.0f, -8.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         8.0f, 0.0f, -8.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         8.0f, 0.0f,  8.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -8.0f, 0.0f,  8.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    // For the circular surface:
    // Allocate the needed VAO, VBO< EBO
    // The normal vectors is specified separately for each vertex. (It is not a generic attribute.)
    // YOU MUST MODIFY THIS TO (A) USE STRIDES OF 8 *sizeof(float), (B) COMMENT IN THE LINES FOR vertTexCoords 
    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	// Store vertices in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); // Store normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc); 
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(vertTexCoords_loc);
    // Enabled the stored normals (so they are not generic)
    // ONCE YOU HAVE TEXTURE COORDINATES WORKING FOR THE CIRCULAR SURFACE,
    //   PUT THE NEXT TWO LINES BACK IN, AND CHANGE THE STRIDE FACTOR TO "8" IN THE PREVIOUS CALLS TO glVertexAttribPointer.
    //glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    //glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices

    // No data has been loaded into the VBO's for the circular surface yet.
    // This is done by the "SamsRemeshCircularSurf" routine.

    // FOR THE BACK WALL: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE FLOOR ABOVE.
    // YOU DO NOT NEED TO REMESH THE BACK WALL - ONE RECTANGLE (TWO TRIANGLES) IS ENOUGH
    float wallVerts[] = {
        -8.0f, 0.0f, -8.0f,    0.0f,0.0f,1.0f,   0.0f, 0.0f,    //bootom left
        8.0f, 0.0f, -8.0f,    0.0f,0.0f,1.0f,   1.0f, 0.0f,    //bootom right
        -8.0f, 8.0f, -8.0f,    0.0f,0.0f,1.0f,   0.0f, 1.0f,    //top left
        8.0f, 8.0f, -8.0f,    0.0f,0.0f,1.0f,   1.0f, 1.0f    //top right

    };
    unsigned int WallElmts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   
    glEnableVertexAttribArray(vertPos_loc);									
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	
    glEnableVertexAttribArray(vertNormal_loc);									
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	
    glEnableVertexAttribArray(vertTexCoords_loc);									
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(WallElmts), WallElmts, GL_STATIC_DRAW);

    setupCube();

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats
    // ******
    // Render the Floor - using a procedural texture map
    // ******
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    glBindVertexArray(myVAO[iWall]);
    materialUnderTexture.LoadIntoShaders();
    viewMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, true);

    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(0.2f, 0.2f);
    LinearMapR4 cubeMat = viewMatrix;

#if 0
    cubeMat = viewMatrix;
    cubeMat.Mult_glTranslate(0.0f, 2.4f, 3.0f);
    cubeMat.Mult_glScale(2.0f);
    glBindVertexArray(myVAO[iCube]);
    metalMaterial.LoadIntoShaders();
    cubeMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);
    glUniform1i(applyTextureLocation, true);
    glDrawArrays(GL_TRIANGLES, 0, 36);
    glUniform1i(applyTextureLocation, false);
    return;
#endif
    
    //stove
    //bottom
    cubeMat.Mult_glTranslate(0.0, 0.1f, -3.0f);
    cubeMat.Mult_glScale(8.0f, 0.2f, 6.0f);
    renderCube(cubeMat, matEntries);

    //top
    cubeMat = viewMatrix;
    cubeMat.Mult_glTranslate(0.0f, 5.0f, -3.0f);
    cubeMat.Mult_glScale(8.0f, 1.0f, 6.0f);
    renderCube(cubeMat, matEntries);
    
    cubeMat = viewMatrix;
    cubeMat.Mult_glTranslate(0.0f, 2.75f, -6.1f);
    cubeMat.Mult_glScale(8.0f, 5.5f, 0.2f);
    renderCube(cubeMat, matEntries);

    cubeMat = viewMatrix;
    cubeMat.Mult_glTranslate( 4.1f, 2.75f, -3.1f);
    cubeMat.Mult_glScale(0.2f, 5.5f, 6.2f);
    renderCube(cubeMat, matEntries);

    cubeMat = viewMatrix;
    cubeMat.Mult_glTranslate(-4.1f, 2.75f, -3.1f);
    cubeMat.Mult_glScale(0.2f, 5.5f, 6.2f);
    renderCube(cubeMat, matEntries);

    LinearMapR4 barMat = viewMatrix;
    barMat.Mult_glTranslate(0.0f, 0.2f, 0.2f);
    barMat.Mult_glRotate(PI / 2, 0.0f, 0.0f, 1.0f);
    barMat.Mult_glScale(0.2f, 4.0f, 0.2f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();
    

    //door frame
    float r = (float)currentTime / 100.0f * ((float)PI / 2.0f);
    cubeMat = viewMatrix;
    cubeMat = axisRotation(cubeMat, 0.0f, -0.1f, -0.1f, r, 'x');
    cubeMat.Mult_glTranslate(3.7f, 2.4f, 0.1f);
    cubeMat.Mult_glScale(0.6f, 4.2f, 0.2f);
    renderCube(cubeMat, matEntries);
    
    cubeMat = viewMatrix;
    cubeMat = axisRotation(cubeMat, 0.0f, -0.1f, -0.1f, r, 'x');
    cubeMat.Mult_glTranslate(-3.7f, 2.4f, 0.1f);
    cubeMat.Mult_glScale(0.6f, 4.2f, 0.2f);
    renderCube(cubeMat, matEntries);

    cubeMat = viewMatrix;
    cubeMat = axisRotation(cubeMat, 0.0f, -0.1f, -0.1f, r, 'x');
    cubeMat.Mult_glTranslate(0.0f,0.6f,0.1f);
    cubeMat.Mult_glScale(6.8f, 1.0f, 0.2f);
    renderCube(cubeMat, matEntries);

    cubeMat = viewMatrix;
    cubeMat = axisRotation(cubeMat, 0.0f, -0.1f, -0.1f, r, 'x');
    cubeMat.Mult_glTranslate(0.0f, 4.1f, 0.1f);
    cubeMat.Mult_glScale(6.8f, 0.8f, 0.2f);
    renderCube(cubeMat, matEntries);

    barMat = viewMatrix;
    barMat = axisRotation(barMat, 0.0f, -0.1f, -0.1f, r, 'x');
    barMat.Mult_glTranslate(0.0f, 4.4f, 0.4f);
    barMat.Mult_glRotate(PI/2,0.0f,0.0f, 1.0f);
    barMat.Mult_glScale(0.2f, 3.0f, 0.2f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();

    //bottons
    barMat = viewMatrix;
    barMat.Mult_glTranslate(0.0f, 5.0f, 0.05f);
    barMat.Mult_glRotate(PI / 2, 1.0f, 0.0f, 0.0f);
    barMat.Mult_glScale(0.3f, 0.05f, 0.3f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();

    barMat = viewMatrix;
    barMat.Mult_glTranslate(1.5f, 5.0f, 0.05f);
    barMat.Mult_glRotate(PI / 2, 1.0f, 0.0f, 0.0f);
    barMat.Mult_glScale(0.3f, 0.05f, 0.3f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();

    barMat = viewMatrix;
    barMat.Mult_glTranslate(-1.5f, 5.0f, 0.05f);
    barMat.Mult_glRotate(PI / 2, 1.0f, 0.0f, 0.0f);
    barMat.Mult_glScale(0.3f, 0.05f, 0.3f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();
    float translation;
    if (currentTime < 50) {
        translation = 0;
    }
    else {
        translation = ((currentTime-50) / 50.0f * 5.0f);
    }
    
    for (int i = 0;  i < 15; i++) {
        barMat = viewMatrix;
        barMat.Mult_glTranslate(-3.5f+i*0.5f, 1.5f, -3.0f+translation);
        barMat.Mult_glRotate(PI / 2, 1.0f, 0.0f, 0.0f);
        barMat.Mult_glScale(0.1f,2.5f,0.1f);
        barMat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texCylinder.Render();
    }

    barMat = viewMatrix;
    barMat.Mult_glTranslate(0.0f, 1.5f, -0.5f + translation);
    barMat.Mult_glRotate(PI / 2, 0.0f, 0.0f, 1.0f);
    barMat.Mult_glScale(0.1f, 3.5f, 0.1f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();

    barMat = viewMatrix;
    barMat.Mult_glTranslate(0.0f, 1.5f, -5.5f + translation);
    barMat.Mult_glRotate(PI / 2, 0.0f, 0.0f, 1.0f);
    barMat.Mult_glScale(0.1f, 3.5f, 0.1f);
    barMat.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    texCylinder.Render();



    donutMaterial.LoadIntoShaders();
    if (clicked!=1) {
        LinearMapR4 donutMat = viewMatrix;
        donutMat.Mult_glTranslate(0.0f, 2.0f, -3.0f + translation);
        donutMat.Mult_glScale(0.8f, 0.5f, 0.8f);
        
        if (clicked == 0 || bakingTime==maxTime)
        {
            if (bakingTime == maxTime) {
                clicked = 0;
            }
            glBindTexture(GL_TEXTURE_2D, TextureNames[2]);
            glUniform1i(applyTextureLocation, true);
        }
        else if (clicked == 2) {
            donutMat.Mult_glScale(0.5f + bakingTime / maxTime * 0.5f);
            glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
            glUniform1i(applyTextureLocation, true);
        }
        donutMat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texTorus.Render();
        glUniform1i(applyTextureLocation, false);
    }

 

    
    check_for_opengl_errors();      // Watch the console window for error messages!
}


void setupCube(){
    float cubeVerts[] = {
        //front face two triangles          Normals                 Texture
        -0.5f, -0.5f, 0.5f,                 0.0f,0.0f,0.5f,         0.25f,0.333f,
        0.5f, -0.5f, 0.5f,                  0.0f,0.0f,0.5f,         0.5f,0.333f,
        0.5f, 0.5f, 0.5f,                   0.0f,0.0f,0.5f,         0.5f,0.666f,

        -0.5f, -0.5f, 0.5f,                 0.0f,0.0f,0.5f,         0.25f,0.333f,
        0.5f, 0.5f, 0.5f,                   0.0f,0.0f,0.5f,         0.5f,0.666f,
        -0.5f,0.5f, 0.5f,                   0.0f,0.0f,0.5f,         0.25f,0.666f,

        //right face
        0.5f, -0.5f, 0.5f,                  0.5f,0.0f,0.0f,         0.5f, 0.333f,
        0.5f, -0.5f, -0.5f,                 0.5f,0.0f,0.0f,         0.75f, 0.333f,
        0.5f, 0.5f, -0.5f,                   0.5f,0.0f,0.0f,        0.75f, 0.666f,

        0.5f, -0.5f, 0.5f,                  0.5f,0.0f,0.0f,         0.5f, 0.333f,
        0.5f, 0.5f, -0.5f,                  0.5f,0.0f,0.0f,         0.75f,0.666f,
        0.5f, 0.5f, 0.5f,                   0.5f,0.0f,0.0f,         0.5f,0.666f,

        //back face
        0.5f, -0.5f, -0.5f,                 0.0f,0.0f,-0.5f,        0.75f,0.333f,
        -0.5f,-0.5f, -0.5f,                 0.0f,0.0f,-0.5f,        1.0f,0.333f,
        -0.5f, 0.5f, -0.5f,                 0.0f,0.0f,-0.5f,        1.0f,0.666f,

        0.5f,-0.5f,-0.5f,                   0.0f,0.0f,-0.5f,        0.75f,0.333f,
        -0.5f,0.5f,-0.5f,                   0.0f,0.0f,-0.5f,        1.0f,0.666f,
        0.5f,0.5f,-0.5f,                    0.0f,0.0f,-0.5f,        0.75f,0.666f,

        //left face
        -0.5f,-0.5f,-0.5f,                  -0.5f,0.0f,0.0f,        0.0f,0.333f,
        -0.5f,-0.5f,0.5f,                   -0.5f,0.0f,0.0f,        0.25f,0.333f,
        -0.5f,0.5f,0.5f,                    -0.5f,0.0f,0.0f,        0.25f,0.666f,

        -0.5f,-0.5f,-0.5f,                  -0.5f,0.0f,0.0f,        0.0f,0.333f,
        -0.5f,0.5f,0.5f,                    -0.5f,0.0f,0.0f,        0.25f,0.666f,
        -0.5f,0.5f,-0.5f,                   -0.5f,0.0f,0.0f,        0.0f,0.666f,

        //top face 
        -0.5f,0.5f,0.5f,                    0.0f,0.5f,0.0f,         0.25f,0.666f,
        0.5f,0.5f,0.5f,                     0.0f,0.5f,0.0f,         0.5f,0.666f,
        0.5f,0.5f,-0.5f,                    0.0f,0.5f,0.0f,         0.5f,1.0f,

        -0.5f,0.5f,0.5f,                    0.0f,0.5f,0.0f,         0.25f,0.666f,
        0.5f,0.5f,-0.5f,                    0.0f,0.5f,0.0f,         0.5f,1.0f,
        -0.5f,0.5f,-0.5f,                   0.0f,0.5f,0.0f,         0.25f,1.0f,

        //Bottom face
        -0.5f,-0.5f,-0.5f,                  0.0f,-0.5f,0.0f,        0.25f,0.0f,
        0.5f,-0.5f,-0.5f,                   0.0f,-0.5f,0.0f,        0.5f,0.0f,
        0.5f,-0.5f,0.5f,                    0.0f,-0.5f,0.0f,        0.5f,0.333f,

        -0.5f,-0.5f,-0.5f,                  0.0f,-0.5f,0.0f,        0.25f,0.0f,
        0.5f,-0.5f,0.5f,                    0.0f,-0.5f,0.0f,        0.5f,0.333f,
        -0.5f,-0.5f,0.5f,                   0.0f,-0.5f,0.0f,        0.25f,0.333f,

    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCube]);
    glBindVertexArray(myVAO[iCube]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cubeVerts), cubeVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(vertPos_loc);
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(vertNormal_loc);
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(vertTexCoords_loc);

}

void renderCube(LinearMapR4 cubematrix,float* matEntries) {
    glBindVertexArray(myVAO[iCube]);
    metalMaterial.LoadIntoShaders();
    cubematrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);
    glUniform1i(applyTextureLocation, true);
    glDrawArrays(GL_TRIANGLES,0,36);
    glUniform1i(applyTextureLocation, false);
}

LinearMapR4 axisRotation(LinearMapR4 mat, float x, float y, float z, float r, char axis) {
    mat.Mult_glTranslate(-x, -y, -z);
    switch (axis)
    {
    case 'x':
        mat.Mult_glRotate(r, 1.0f, 0.0f, 0.0f);
        break;
    case 'y':
        mat.Mult_glRotate(r, 0.0f, 1.0f, 0.0f);
        break;
    case 'z':
        mat.Mult_glRotate(r, 0.0f, 0.0f, 1.0f);
        break;
    }
    
    mat.Mult_glTranslate(x, y, z);
    return mat;
}